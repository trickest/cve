### [CVE-2024-26727](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-26727)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5.9%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=917d608fe375041eb7f29befa6a6d7fd3cf32dde%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:btrfs: do not ASSERT() if the newly created subvolume already got read[BUG]There is a syzbot crash, triggered by the ASSERT() during subvolumecreation: assertion failed: !anon_dev, in fs/btrfs/disk-io.c:1319 ------------[ cut here ]------------ kernel BUG at fs/btrfs/disk-io.c:1319! invalid opcode: 0000 [#1] PREEMPT SMP KASAN RIP: 0010:btrfs_get_root_ref.part.0+0x9aa/0xa60  <TASK>  btrfs_get_new_fs_root+0xd3/0xf0  create_subvol+0xd02/0x1650  btrfs_mksubvol+0xe95/0x12b0  __btrfs_ioctl_snap_create+0x2f9/0x4f0  btrfs_ioctl_snap_create+0x16b/0x200  btrfs_ioctl+0x35f0/0x5cf0  __x64_sys_ioctl+0x19d/0x210  do_syscall_64+0x3f/0xe0  entry_SYSCALL_64_after_hwframe+0x63/0x6b ---[ end trace 0000000000000000 ]---[CAUSE]During create_subvol(), after inserting root item for the newly createdsubvolume, we would trigger btrfs_get_new_fs_root() to get thebtrfs_root of that subvolume.The idea here is, we have preallocated an anonymous device number forthe subvolume, thus we can assign it to the new subvolume.But there is really nothing preventing things like backref walk to readthe new subvolume.If that happens before we call btrfs_get_new_fs_root(), the subvolumewould be read out, with a new anonymous device number assigned already.In that case, we would trigger ASSERT(), as we really expect no one toread out that subvolume (which is not yet accessible from the fs).But things like backref walk is still possible to trigger the read onthe subvolume.Thus our assumption on the ASSERT() is not correct in the first place.[FIX]Fix it by removing the ASSERT(), and just free the @anon_dev, reset itto 0, and continue.If the subvolume tree is read out by something else, it should havealready get a new anon_dev assigned thus we only need to free thepreallocated one.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

