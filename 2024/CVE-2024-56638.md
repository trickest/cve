### [CVE-2024-56638](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-56638)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3a07327d10a09379315c844c63f27941f5081e0a%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:netfilter: nft_inner: incorrect percpu area handling under softirqSoftirq can interrupt ongoing packet from process context that iswalking over the percpu area that contains inner header offsets.Disable bh and perform three checks before restoring the percpu innerheader offsets to validate that the percpu area is valid for thisskbuff:1) If the NFT_PKTINFO_INNER_FULL flag is set on, then this skbuff   has already been parsed before for inner header fetching to   register.2) Validate that the percpu area refers to this skbuff using the   skbuff pointer as a cookie. If there is a cookie mismatch, then   this skbuff needs to be parsed again.3) Finally, validate if the percpu area refers to this tunnel type.Only after these three checks the percpu area is restored to a on-stackcopy and bh is enabled again.After inner header fetching, the on-stack copy is stored back to thepercpu area.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/cku-heise/euvd-api-doc

