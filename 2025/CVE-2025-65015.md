### [CVE-2025-65015](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-65015)
![](https://img.shields.io/static/v1?label=Product&message=joserfc&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=%3E%3D%201.3.3%2C%20%3C%201.3.5%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=%3E%3D%201.4.0%2C%20%3C%201.4.2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-770%3A%20Allocation%20of%20Resources%20Without%20Limits%20or%20Throttling&color=brightgreen)

### Description

joserfc is a Python library that provides an implementation of several JSON Object Signing and Encryption (JOSE) standards. In versions from 1.3.3 to before 1.3.5 and from 1.4.0 to before 1.4.2, the ExceededSizeError exception messages are embedded with non-decoded JWT token parts and may cause Python logging to record an arbitrarily large, forged JWT payload. In situations where a misconfigured — or entirely absent — production-grade web server sits in front of a Python web application, an attacker may be able to send arbitrarily large bearer tokens in the HTTP request headers. When this occurs, Python logging or diagnostic tools (e.g., Sentry) may end up processing extremely large log messages containing the full JWT header during the joserfc.jwt.decode() operation. The same behavior also appears when validating claims and signature payload sizes, as the library raises joserfc.errors.ExceededSizeError() with the full payload embedded in the exception message. Since the payload is already fully loaded into memory at this stage, the library cannot prevent or reject it. This issue has been patched in versions 1.3.5 and 1.4.2.

### POC

#### Reference
- https://github.com/authlib/joserfc/security/advisories/GHSA-frfh-8v73-gjg4

#### Github
No PoCs found on GitHub currently.

