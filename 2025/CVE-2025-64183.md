### [CVE-2025-64183](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-64183)
![](https://img.shields.io/static/v1?label=Product&message=openexr&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=%3E%3D%203.2.0%2C%20%3C%203.2.5%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=%3E%3D%203.3.0%2C%20%3C%203.3.6%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=%3E%3D%203.4.0%2C%20%3C%203.4.3%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-416%3A%20Use%20After%20Free&color=brightgreen)

### Description

OpenEXR provides the specification and reference implementation of the EXR file format, an image storage format for the motion picture industry. In versions 3.2.0 through 3.2.4, 3.3.0 through 3.3.5, and 3.4.0 through 3.4.2, there is a use-after-free in PyObject_StealAttrString of pyOpenEXR_old.cpp. The legacy adapter defines PyObject_StealAttrString that calls PyObject_GetAttrString to obtain a new reference, immediately decrefs it, and returns the pointer. Callers then pass this dangling pointer to APIs like PyLong_AsLong/PyFloat_AsDouble, resulting in a use-after-free. This is invoked in multiple places (e.g., reading PixelType.v, Box2i, V2f, etc.) Versions 3.2.5, 3.3.6, and 3.4.3 fix the issue.

### POC

#### Reference
- https://github.com/AcademySoftwareFoundation/openexr/security/advisories/GHSA-57cw-j6vp-2p9m

#### Github
No PoCs found on GitHub currently.

